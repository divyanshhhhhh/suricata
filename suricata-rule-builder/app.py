#!/usr/bin/env python3
"""
Suricata Rule Builder Dashboard
A web-based interface for creating, editing, and managing Suricata IDS/IPS rules.
"""

from flask import Flask, render_template, request, jsonify
import subprocess
import os
import re
import tempfile
import json
from datetime import datetime

app = Flask(__name__)

# Configuration
RULES_FILE = '/etc/suricata/rules/custom.rules'
FALLBACK_RULES_FILE = os.path.join(os.path.dirname(__file__), 'custom.rules')

# Use fallback if main rules file doesn't exist or isn't writable
if not os.path.exists(RULES_FILE) or not os.access(os.path.dirname(RULES_FILE), os.W_OK):
    RULES_FILE = FALLBACK_RULES_FILE
    # Create the file if it doesn't exist
    if not os.path.exists(RULES_FILE):
        with open(RULES_FILE, 'w') as f:
            f.write('# Suricata Custom Rules\n')
            f.write('# Generated by Suricata Rule Builder\n\n')


def parse_rule(rule_line):
    """
    Parse a Suricata rule string into components.
    Returns a dictionary with rule parts or None if invalid.
    """
    if not rule_line.strip() or rule_line.strip().startswith('#'):
        return None

    # Basic regex pattern for Suricata rule
    # Format: action protocol src_ip src_port direction dst_ip dst_port (options)
    pattern = r'^(\w+)\s+(\w+)\s+(\S+)\s+(\S+)\s+(->|<>)\s+(\S+)\s+(\S+)\s+\((.*)\)$'
    match = re.match(pattern, rule_line.strip())

    if not match:
        return None

    action, protocol, src_ip, src_port, direction, dst_ip, dst_port, options_str = match.groups()

    # Parse options
    options = {}
    sid = None
    msg = None

    # Extract options (simplified parsing)
    option_pattern = r'(\w+):\s*([^;]+);'
    for opt_match in re.finditer(option_pattern, options_str):
        key, value = opt_match.groups()
        value = value.strip()

        # Remove quotes from msg
        if key == 'msg' and value.startswith('"') and value.endswith('"'):
            value = value[1:-1]

        options[key] = value

        if key == 'sid':
            sid = int(value)
        elif key == 'msg':
            msg = value

    return {
        'action': action,
        'protocol': protocol,
        'src_ip': src_ip,
        'src_port': src_port,
        'direction': direction,
        'dst_ip': dst_ip,
        'dst_port': dst_port,
        'options': options,
        'sid': sid,
        'msg': msg,
        'raw': rule_line.strip()
    }


def build_rule(data):
    """
    Build a Suricata rule string from form data.
    """
    action = data.get('action', 'alert')
    protocol = data.get('protocol', 'tcp')
    src_ip = data.get('src_ip', 'any')
    src_port = data.get('src_port', 'any')
    direction = data.get('direction', '->')
    dst_ip = data.get('dst_ip', 'any')
    dst_port = data.get('dst_port', 'any')

    # Build options string
    options = []

    # msg is required
    msg = data.get('msg', 'Suricata Rule')
    options.append(f'msg:"{msg}"')

    # Add content options
    contents = data.get('contents', [])
    for content in contents:
        if content.get('value'):
            modifiers = []
            if content.get('nocase'):
                modifiers.append('nocase')
            if content.get('offset'):
                modifiers.append(f'offset:{content["offset"]}')
            if content.get('depth'):
                modifiers.append(f'depth:{content["depth"]}')

            options.append(f'content:"{content["value"]}"')
            for mod in modifiers:
                options.append(mod)

    # Add HTTP keywords (protocol-specific)
    if protocol == 'http':
        if data.get('http_method'):
            options.append(f'http.method; content:"{data["http_method"]}"')
        if data.get('http_uri'):
            options.append(f'http.uri; content:"{data["http_uri"]}"')
        if data.get('http_user_agent'):
            options.append(f'http.user_agent; content:"{data["http_user_agent"]}"')
        if data.get('http_host'):
            options.append(f'http.host; content:"{data["http_host"]}"')
        if data.get('http_cookie'):
            options.append(f'http.cookie; content:"{data["http_cookie"]}"')
        if data.get('http_referer'):
            options.append(f'http.referer; content:"{data["http_referer"]}"')
        if data.get('http_content_type'):
            options.append(f'http.content_type; content:"{data["http_content_type"]}"')
        if data.get('http_stat_code'):
            options.append(f'http.stat_code; content:"{data["http_stat_code"]}"')
        if data.get('http_request_body'):
            options.append('http.request_body')
        if data.get('http_response_body'):
            options.append('http.response_body')
        if data.get('file_data'):
            options.append('file.data')

    # Add TLS keywords (protocol-specific)
    if protocol == 'tls':
        if data.get('tls_version'):
            options.append(f'tls.version:"{data["tls_version"]}"')
        if data.get('tls_sni'):
            options.append(f'tls.sni; content:"{data["tls_sni"]}"')
        if data.get('tls_subject'):
            options.append(f'tls.subject; content:"{data["tls_subject"]}"')
        if data.get('tls_issuer'):
            options.append(f'tls.issuer; content:"{data["tls_issuer"]}"')
        if data.get('tls_cert_fingerprint'):
            options.append(f'tls.cert_fingerprint; content:"{data["tls_cert_fingerprint"]}"')
        if data.get('ja3_hash'):
            options.append(f'ja3.hash; content:"{data["ja3_hash"]}"')
        if data.get('ja3s_hash'):
            options.append(f'ja3s.hash; content:"{data["ja3s_hash"]}"')

    # Add DNS keywords (protocol-specific)
    if protocol == 'dns':
        if data.get('dns_query'):
            options.append(f'dns.query; content:"{data["dns_query"]}"')
        if data.get('dns_query_type'):
            options.append(f'dns.query.type:{data["dns_query_type"]}')
        if data.get('dns_answer'):
            options.append(f'dns.answer; content:"{data["dns_answer"]}"')
        if data.get('dns_opcode'):
            options.append(f'dns.opcode:{data["dns_opcode"]}')

    # Add flow options
    flow_options = []
    if data.get('flow_established'):
        flow_options.append('established')
    if data.get('flow_to_server'):
        flow_options.append('to_server')
    if data.get('flow_to_client'):
        flow_options.append('to_client')
    if data.get('flow_from_server'):
        flow_options.append('from_server')
    if data.get('flow_from_client'):
        flow_options.append('from_client')

    if flow_options:
        options.append(f'flow:{",".join(flow_options)}')

    # Add classification and priority
    if data.get('classtype'):
        options.append(f'classtype:{data["classtype"]}')

    if data.get('priority'):
        options.append(f'priority:{data["priority"]}')

    # Add threshold options
    if data.get('threshold_type'):
        threshold = f'threshold:type {data["threshold_type"]}'
        if data.get('threshold_track'):
            threshold += f',track {data["threshold_track"]}'
        if data.get('threshold_count'):
            threshold += f',count {data["threshold_count"]}'
        if data.get('threshold_seconds'):
            threshold += f',seconds {data["threshold_seconds"]}'
        options.append(threshold)

    # Add reference if provided
    if data.get('reference'):
        options.append(f'reference:{data["reference"]}')

    # sid and rev are required
    sid = data.get('sid', 1000000)
    rev = data.get('rev', 1)
    options.append(f'sid:{sid}')
    options.append(f'rev:{rev}')

    # Build the complete rule
    options_str = '; '.join(options) + ';'
    rule = f'{action} {protocol} {src_ip} {src_port} {direction} {dst_ip} {dst_port} ({options_str})'

    return rule


@app.route('/')
def index():
    """Render the main dashboard page."""
    return render_template('index.html')


@app.route('/api/rules', methods=['GET'])
def get_rules():
    """Get all rules from the rules file."""
    try:
        rules = []

        if os.path.exists(RULES_FILE):
            with open(RULES_FILE, 'r') as f:
                for line_num, line in enumerate(f, 1):
                    parsed = parse_rule(line)
                    if parsed:
                        parsed['line_num'] = line_num
                        rules.append(parsed)

        return jsonify({
            'success': True,
            'rules': rules,
            'file': RULES_FILE
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/rules', methods=['POST'])
def save_rule():
    """Save a new rule to the rules file."""
    try:
        data = request.json

        # Build the rule
        if 'raw_rule' in data and data['raw_rule']:
            rule = data['raw_rule']
        else:
            rule = build_rule(data)

        # Validate the rule first
        validation = validate_rule_syntax(rule)
        if not validation['valid']:
            return jsonify({
                'success': False,
                'error': f'Invalid rule syntax: {validation.get("error", "Unknown error")}'
            }), 400

        # Append to rules file
        with open(RULES_FILE, 'a') as f:
            f.write(rule + '\n')

        return jsonify({
            'success': True,
            'message': 'Rule saved successfully',
            'rule': rule
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/rules/<int:sid>', methods=['PUT'])
def update_rule(sid):
    """Update an existing rule by SID."""
    try:
        data = request.json

        # Build the new rule
        if 'raw_rule' in data and data['raw_rule']:
            new_rule = data['raw_rule']
        else:
            new_rule = build_rule(data)

        # Validate the rule first
        validation = validate_rule_syntax(new_rule)
        if not validation['valid']:
            return jsonify({
                'success': False,
                'error': f'Invalid rule syntax: {validation.get("error", "Unknown error")}'
            }), 400

        # Read all rules
        rules = []
        updated = False

        if os.path.exists(RULES_FILE):
            with open(RULES_FILE, 'r') as f:
                rules = f.readlines()

        # Find and update the rule with matching SID
        for i, line in enumerate(rules):
            parsed = parse_rule(line)
            if parsed and parsed.get('sid') == sid:
                rules[i] = new_rule + '\n'
                updated = True
                break

        if not updated:
            return jsonify({
                'success': False,
                'error': f'Rule with SID {sid} not found'
            }), 404

        # Write back to file
        with open(RULES_FILE, 'w') as f:
            f.writelines(rules)

        return jsonify({
            'success': True,
            'message': 'Rule updated successfully',
            'rule': new_rule
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/rules/<int:sid>', methods=['DELETE'])
def delete_rule(sid):
    """Delete a rule by SID."""
    try:
        # Read all rules
        rules = []
        deleted = False

        if os.path.exists(RULES_FILE):
            with open(RULES_FILE, 'r') as f:
                rules = f.readlines()

        # Filter out the rule with matching SID
        new_rules = []
        for line in rules:
            parsed = parse_rule(line)
            if parsed and parsed.get('sid') == sid:
                deleted = True
            else:
                new_rules.append(line)

        if not deleted:
            return jsonify({
                'success': False,
                'error': f'Rule with SID {sid} not found'
            }), 404

        # Write back to file
        with open(RULES_FILE, 'w') as f:
            f.writelines(new_rules)

        return jsonify({
            'success': True,
            'message': 'Rule deleted successfully'
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/validate', methods=['POST'])
def validate_rule():
    """Validate rule syntax using Suricata."""
    try:
        data = request.json
        rule = data.get('rule', '')

        if not rule:
            return jsonify({
                'valid': False,
                'error': 'No rule provided'
            }), 400

        result = validate_rule_syntax(rule)
        return jsonify(result)
    except Exception as e:
        return jsonify({
            'valid': False,
            'error': str(e)
        }), 500


def validate_rule_syntax(rule):
    """
    Validate a Suricata rule using suricata -T command.
    Returns a dict with 'valid' boolean and optional 'error' message.
    """
    try:
        # Create a temporary file with the rule
        with tempfile.NamedTemporaryFile(mode='w', suffix='.rules', delete=False) as f:
            temp_file = f.name
            f.write(rule + '\n')

        try:
            # Try to run suricata -T (test mode)
            # Check if suricata is available
            result = subprocess.run(
                ['which', 'suricata'],
                capture_output=True,
                text=True
            )

            if result.returncode != 0:
                # Suricata not installed, do basic syntax validation
                return basic_rule_validation(rule)

            # Run suricata in test mode
            result = subprocess.run(
                ['suricata', '-T', '-S', temp_file],
                capture_output=True,
                text=True,
                timeout=5
            )

            # Check output for errors
            output = result.stdout + result.stderr

            if 'ERROR' in output or 'FATAL' in output:
                # Extract error message
                error_lines = [line for line in output.split('\n') if 'ERROR' in line or 'FATAL' in line]
                error_msg = error_lines[0] if error_lines else 'Unknown error'
                return {
                    'valid': False,
                    'error': error_msg
                }

            return {
                'valid': True,
                'message': 'Rule syntax is valid'
            }
        finally:
            # Clean up temp file
            if os.path.exists(temp_file):
                os.unlink(temp_file)

    except subprocess.TimeoutExpired:
        return {
            'valid': False,
            'error': 'Validation timeout'
        }
    except Exception as e:
        # Fallback to basic validation
        return basic_rule_validation(rule)


def basic_rule_validation(rule):
    """
    Basic rule validation when Suricata is not available.
    Checks for basic syntax structure.
    """
    # Basic pattern check
    pattern = r'^(alert|pass|drop|reject|rejectsrc|rejectdst|rejectboth)\s+(tcp|udp|icmp|ip|http|dns|tls|ssh|ftp|smtp|smb)\s+\S+\s+\S+\s+(->|<>)\s+\S+\s+\S+\s+\(.+sid:\d+.+\)$'

    if not re.match(pattern, rule.strip()):
        return {
            'valid': False,
            'error': 'Rule does not match basic Suricata syntax. Format: action protocol src_ip src_port direction dst_ip dst_port (options with sid)'
        }

    # Check for required options
    if 'sid:' not in rule:
        return {
            'valid': False,
            'error': 'Rule must contain sid (Signature ID)'
        }

    if 'msg:' not in rule:
        return {
            'valid': False,
            'error': 'Rule should contain msg (message description)'
        }

    return {
        'valid': True,
        'message': 'Rule syntax appears valid (basic check - Suricata not available for full validation)'
    }


@app.route('/api/reload', methods=['POST'])
def reload_service():
    """Reload Suricata service."""
    try:
        # Try different methods to reload Suricata
        commands = [
            ['sudo', 'systemctl', 'reload', 'suricata'],
            ['sudo', 'service', 'suricata', 'reload'],
            ['sudo', 'killall', '-USR2', 'suricata']
        ]

        for cmd in commands:
            try:
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=10
                )

                if result.returncode == 0:
                    return jsonify({
                        'success': True,
                        'message': 'Suricata service reload initiated'
                    })
            except (subprocess.TimeoutExpired, FileNotFoundError):
                continue

        # If all methods fail
        return jsonify({
            'success': False,
            'message': 'Could not reload Suricata service. You may need to configure sudo permissions or reload manually.',
            'hint': 'Run: sudo systemctl reload suricata'
        }), 500

    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/next-sid', methods=['GET'])
def get_next_sid():
    """Get the next available SID."""
    try:
        max_sid = 1000000  # Default starting SID

        if os.path.exists(RULES_FILE):
            with open(RULES_FILE, 'r') as f:
                for line in f:
                    parsed = parse_rule(line)
                    if parsed and parsed.get('sid'):
                        max_sid = max(max_sid, parsed['sid'])

        next_sid = max_sid + 1

        return jsonify({
            'success': True,
            'next_sid': next_sid
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/export', methods=['GET'])
def export_rules():
    """Export all rules as JSON."""
    try:
        rules = []

        if os.path.exists(RULES_FILE):
            with open(RULES_FILE, 'r') as f:
                for line in f:
                    parsed = parse_rule(line)
                    if parsed:
                        rules.append(parsed)

        return jsonify({
            'success': True,
            'rules': rules,
            'exported_at': datetime.now().isoformat(),
            'total': len(rules)
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/import', methods=['POST'])
def import_rules():
    """Import rules from JSON."""
    try:
        data = request.json
        rules = data.get('rules', [])

        if not rules:
            return jsonify({
                'success': False,
                'error': 'No rules provided'
            }), 400

        # Validate and write rules
        imported = 0
        errors = []

        with open(RULES_FILE, 'a') as f:
            for rule_data in rules:
                try:
                    if isinstance(rule_data, str):
                        rule = rule_data
                    else:
                        rule = rule_data.get('raw', build_rule(rule_data))

                    # Validate
                    validation = validate_rule_syntax(rule)
                    if validation['valid']:
                        f.write(rule + '\n')
                        imported += 1
                    else:
                        errors.append(f"Invalid rule: {validation.get('error')}")
                except Exception as e:
                    errors.append(f"Error importing rule: {str(e)}")

        return jsonify({
            'success': True,
            'imported': imported,
            'errors': errors
        })
    except Exception as e:
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


if __name__ == '__main__':
    # Run on port 5500 as specified
    app.run(debug=True, host='0.0.0.0', port=5500)
